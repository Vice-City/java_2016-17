package hr.fer.zemris.bf.utils;

import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import hr.fer.zemris.bf.model.Node;
import hr.fer.zemris.bf.parser.Parser;

/**
 * Contains a number of static methods that are useful for working
 * with Node expressions generated by {@link Parser}.
 * 
 * @author Vice Ivušić
 *
 */
public class Util {

	/**
	 * Creates an array of boolean values for each possible combination
	 * of the specified variables, and applies the specified function
	 * onto each set of possible boolean values.
	 * 
	 * @param variables list of boolean variable names
	 * @param consumer Consumer object containing the logic for interacting
	 * 		  with each created array of boolean values
	 * @throws IllegalArgumentException if any of the arguments is null
	 */
	public static void forEach(List<String> variables, Consumer<boolean[]> consumer) {
		if (variables == null || consumer == null) {
			throw new IllegalArgumentException("None of the arguments may be null!");
		}
		
		int numberOfVariables = variables.size();
		int amountOfCombinations = 1 << numberOfVariables;
		
		for (int currentNumber = 0; currentNumber < amountOfCombinations; currentNumber++) {
			// consumer is free to use this array since it is not referenced anywhere else
			boolean[] bools = new boolean[numberOfVariables];
			
			for (int i = 0, n = bools.length; i < n; i++) {
				// check each bit of current number and build the boolean array
				bools[n-i-1] = ((currentNumber >> i) & 0x1) == 0 ? false : true;
			}
			
			consumer.accept(bools);
		}
	}
	
	/**
	 * Returns a set of boolean value sets which evaluate to the specified
	 * expression value for the specified list of variables and the specified
	 * expression. The values returned will be in the same order as they would
	 * in a truth table.
	 * 
	 * @param variables list of variables
	 * @param expression Node of boolean expression
	 * @param expressionValue desired boolean value to match against
	 * @return set of boolean value sets which match the specified parameters
	 * @throws IllegalArgumentException if the specified expression contains
	 * 		   variables which aren't declared or if any of the arguments is null
	 */
	public static Set<boolean[]> filterAssignments(List<String> variables, Node expression, boolean expressionValue) {
		if (variables == null || expression == null) {
			throw new IllegalArgumentException("None of the arguments may be null!");
		}
		
		Set<boolean[]> wantedBooleans = new LinkedHashSet<>();
		ExpressionEvaluator evaluator = new ExpressionEvaluator(variables);
		
		forEach(
				variables, 
				values -> {
					evaluator.setValues(values);
					expression.accept(evaluator);
					boolean result = evaluator.getResult();
					
					if (result == expressionValue) {
						wantedBooleans.add(values);
					}
				}
		);
		
		return wantedBooleans;
	}
	
	/**
	 * Returns a non-negative integer converted from the specified array of
	 * boolean values. Each true and false value contained in the
	 * specified array can be treated as one bit of the resulting integer.
	 * The last boolean value in the array is regarded as the lowest
	 * bit of the resulting integer.
	 * 
	 * @param values array of boolean values
	 * @return integer representing the specified array of boolean values
	 * @throws IllegalArgumentException if the specified array of values is null
	 * 		   or if the array contains more than 31 boolean values
	 */
	public static int booleanArrayToInt(boolean[] values) {
		if (values == null) {
			throw new IllegalArgumentException("Argument values cannot be null!");
		}
		
		if (values.length > 31) {
			throw new IllegalArgumentException("Size of boolean array must be below 32!");
		}
		
		int result = 0;
		for (int i = 0, n = values.length; i < n; i++) {
			if (values[i] == true) {
				// for each true value, add two to the power of its position's power value
				result += 1 << n-i-1;
			}
		}
		
		return result;
	}
	
	/**
	 * Returns an ordered set of the specified expression's minterms,
	 * i.e. the indexes of the truth table entries for which
	 * the expression evaluates to true.
	 * 
	 * @param variables list of variable names
	 * @param expression Node of boolean expression
	 * @return ordered set of the minterms of the specified expression
	 * @throws IllegalArgumentException if the specified expression contains
	 * 		   variables which aren't declared or if any of the arguments is null
	 */
	public static Set<Integer> toSumOfMinterms(List<String> variables, Node expression) {
		return truthTableIndexes(variables, expression, true);
	}
	
	/**
	 * Returns an ordered set of the specified expression's maxterms,
	 * i.e. the indexes of the truth table entries for which
	 * the expression evaluates to false.
	 * 
	 * @param variables list of variable names
	 * @param expression Node of boolean expression
	 * @return ordered set of the maxterms of the specified expression
	 * @throws IllegalArgumentException if the specified expression contains
	 * 		   variables which aren't declared or if any of the arguments is null
	 */
	public static Set<Integer> toProductOfMaxterms(List<String> variables, Node expression) {
		return truthTableIndexes(variables, expression, false);
	}
	
	/**
	 * Helper method which returns a set of indexes of the truth
	 * table entries for which the specified expression evaluates
	 * to the specified expression value.
	 * 
	 * @param variables list of variable names
	 * @param expression Node of boolean expression
	 * @param expressionValue desired boolean value to filter against
	 * @return ordered set of indexes of the truth table entries which satisfy the parameters
	 * @throws IllegalArgumentException if the specified expression contains
	 * 		   variables which aren't declared or if any of the arguments is null
	 */
	private static Set<Integer> truthTableIndexes(List<String> variables, Node expression, boolean expressionValue) {
		if (variables == null || expression == null) {
			throw new IllegalArgumentException("None of the arguments may be null!");
		}
		
		return filterAssignments(variables, expression, expressionValue)
			.stream()
			.map(boolArray -> booleanArrayToInt(boolArray))
			.collect(Collectors.toCollection(LinkedHashSet::new))
		;
	}
	
	/*
	 ************************************************************
	 ********************                    ********************
	 ********************       TASK1        ********************
	 ********************                    ********************
	 ************************************************************
	 */
	
	/**
	 * Returns the bit representation of the specified integer as
	 * an array of n bytes. The bits are written in 2-complement
	 * form, with the highest bit in the first position inside the
	 * array of corresponding bytes. The byte values will be either
	 * 0 (representing the bit 0) or 1 (representing the bit 1).
	 * 
	 * <p>Note that if the specified length of the resulting array
	 * is smaller than what the specified integer needs to store
	 * all of its bits, information will be lost without any warning.
	 * 
	 * <p>For example, for x=5 and n=2, the resulting array will be
	 * [0, 1]. For x=-1 and n=1, the resulting array will be [1],
	 * which might otherwise be interpreted as the integer 1.
	 * 
	 * @param x integer to convert to array of bytes representing its bits
	 * @param n desired length of the resulting array of bytes
	 * @return array of bytes representing the specified integer's bits
	 * @throws IllegalArgumentException if the specified length isn't
	 * 		   between 1 and 32
	 */
	public static byte[] indexToByteArray(int x, int n) {
		if (n < 1 || n > 32) {
			throw new IllegalArgumentException("Argument n must be between 1 and 32!");
		}
		
		byte[] result = new byte[n];
		for (int i = 0; i < n; i++) {
			result[n-i-1] = (byte) ((x >> i) & 0x1);
		}
		
		return result;
	}
	
}
