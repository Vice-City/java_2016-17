package hr.fer.zemris.bf.lexer;

import java.util.HashMap;
import java.util.Map;

/**
 * Represents a text tokenizer. Lexer goes through given text character
 * by character and generates a sequence of tokens which can be
 * retrieved through its API. The tokens generated by this Lexer are those
 * representing:
 * 
 * <p><ul>
 *    <li>boolean variables - any word starting with a letter and potentially
 *    consisting of other letters, numbers or underscores;
 *    <li>boolean constants - the words 'true' and 'false', along with the
 *    numbers '0' and '1';
 *    <li>boolean operators - either their lexical form (and, or, xor and not)
 *    or their symbolic form (*, +, :+: and !);
 *    <li>open brackets and closed brackets;
 *    <li>a token indicating the end of file (i.e. expression) has been reached.
 * </ul>
 * 
 * <p>Tokenization completely disregards case. Offers methods for generating 
 * the next token and for retrieving the last generated token, as well as for
 * retrieving the index of the last unprocessed character at any given moment.
 * 
 * @author Vice Ivušić
 *
 */
public class Lexer {

	/** array containing all the characters the text is composed of */
	private final char[] data;
	/** last generated token */
	private Token token;
	/** index of the last unprocessed character */
	private int currentIndex;
	
	/** map with operator symbols and identifiers mapped to their names */
	private static final Map<String, String> operatorMap;
	
	static {
		operatorMap = new HashMap<>();
		
		operatorMap.put("*", "and");
		operatorMap.put("+", "or");
		operatorMap.put(":+:", "xor");
		operatorMap.put("!", "not");
		
		operatorMap.put("and", "and");
		operatorMap.put("or", "or");
		operatorMap.put("xor", "xor");
		operatorMap.put("not", "not");
	}
	
	/**
	 * Creates a new Lexer from the specified text.
	 * 
	 * @param text text to be tokenized
	 * @throws IllegalArgumentException if the specified text is null
	 */
	public Lexer(String text) {
		if (text == null) {
			throw new IllegalArgumentException("Argument text cannot be null!");
		}
		
		data = text.toCharArray();
	}
	
	/**
	 * Generates and returns the next token.
	 * 
	 * @return generated token
	 * @throws LexerException if there was an error during tokenizing
	 */
	public Token nextToken() {
		extractNextToken();
		return token;
	}
	
	/**
	 * Returns the last generated token. Does <b>not</b> generate a new token!
	 * 
	 * @return last generated token
	 * @throws IllegalStateException if called before {@code nextToken} has 
	 * 		   been called at least once
	 */
	public Token getToken() {
		if (token == null) {
			throw new IllegalStateException(
					"Must call nextToken at least once before retrieving token!"
			);
		}
		
		return token;
	}
	
	/**
	 * Returns the last unprocessed character's index.
	 * 
	 * @return last unprocessed character's index
	 */
	public int getIndex() {
		return currentIndex;
	}

	/**
	 * Helper method which generates and stores the next token.
	 */
	private void extractNextToken() {
		if (token != null && token.getTokenType() == TokenType.EOF) {
			throw new LexerException("Lexer has reached EOF; nothing more to read!");
		}
		
		skipWhitespace();
		
		if (currentIndex == data.length) {
			token = new Token(TokenType.EOF, null);
			return;
		}
		
		char c = data[currentIndex];
		
		if (Character.isLetter(c)) {
			tokenizeWord();
			return;
		}
		
		if (Character.isDigit(c)) {
			tokenizeNumber();
			return;
		}
		
		if (c == '(') {
			token = new Token(TokenType.OPEN_BRACKET, c);
			currentIndex++;
			return;
		}

		if (c == ')') {
			token = new Token(TokenType.CLOSED_BRACKET, c);
			currentIndex++;
			return;
		}
		
		if (c == ':') {
			// if current character is at end of file
			if (currentIndex > data.length-3) {
				throw new LexerException(
						addInfo("':' must be followed by '+:'!")
				);
			}
			
			String xorToken = String.valueOf(data, currentIndex, 3);
			
			if (!":+:".equals(xorToken)) {
				throw new LexerException(
						addInfo("Expected ':+:' but received: '"+xorToken+".")
				);
			}
			
			token = new Token(TokenType.OPERATOR, operatorMap.get(xorToken));
			currentIndex += 3;
			return;
		}
		
		if (c == '*' || c == '+' || c == '!') {
			token = new Token(TokenType.OPERATOR, operatorMap.get(Character.toString(c)));
			currentIndex++;
			return;
		}
		
		throw new LexerException(
				addInfo("Found illegal character: '"+c+"'.")
		);
	}
	
	/**
	 * Helper method which tokenizes and stores the next valid number.
	 */
	private void tokenizeNumber() {
		StringBuilder sb = new StringBuilder();
		
		char c;
		while (currentIndex < data.length) {
			c = data[currentIndex];
			
			if (!Character.isDigit(c)) {
				break;
			}
			
			sb.append(c);
			currentIndex++;
		}
		
		String numberToken = sb.toString();
		
		if (numberToken.equals("0")) {
			token = new Token(TokenType.CONSTANT, false);
			return;
		}
		
		if (numberToken.equals("1")) {
			token = new Token(TokenType.CONSTANT, true);
			return;
		}
		
		throw new LexerException(
				addInfo("Unexpected number: "+numberToken+".")
		);
	}

	/**
	 * Helper method which generates and stores the next appropriate letter-based token.
	 */
	private void tokenizeWord() {
		StringBuilder sb = new StringBuilder();
		
		char c;
		while (currentIndex < data.length) {
			c = data[currentIndex];
			
			if (!Character.isLetterOrDigit(c) && c != '_') {
				break;
			}
			
			sb.append(c);
			currentIndex++;
		}
		
		String lowercaseToken = sb.toString().toLowerCase();
		
		if (operatorMap.containsKey(lowercaseToken)) {
			token = new Token(TokenType.OPERATOR, operatorMap.get(lowercaseToken));
			return;
		}
		
		if (lowercaseToken.equals("true")) {
			token = new Token(TokenType.CONSTANT, true);
			return;
		}
		
		if (lowercaseToken.equals("false")) {
			token = new Token(TokenType.CONSTANT, false);
			return;
		}
		
		token = new Token(TokenType.VARIABLE, lowercaseToken.toUpperCase());
	}

	/**
	 * Helper method which skips over any whitespace in the text.
	 */
	private void skipWhitespace() {
		char c;
		while (currentIndex < data.length) {
			c = data[currentIndex];
			
			if (!Character.isWhitespace(c)) {
				break;
			}
			
			currentIndex++;
		}
	}
	
	/**
	 * Helper method which wraps the specified string with information
	 * about the last unprocessed character's index.
	 * 
	 * @param message informative message
	 * @return message with information about the last unprocessed character's index
	 */
	private String addInfo(String message) {
		return String.format("Near character index %d: %s", currentIndex, message);
	}
}
